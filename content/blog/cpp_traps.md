+++
title = "C++ 陷阱"
date = "2025-12-11"
description = "你掉进陷阱啦！"
draft = false

[taxonomies]
tags = ["C++"]
+++

## 1. 当通过基指针删除派生对象时，可能会导致内存泄露
### 问题描述
当基类指针指向派生类对象，且基类的析构函数**非虚函数**时，通过基指针执行`delete`，只会调用基类的析构函数，不会调用派生类的析构函数，导致派生类部分的资源未被释放，进而引发内存泄漏。
### 原理
原因是 C++ 的静态绑定机制：非虚析构函数的调用地址在编译期确定，`delete`基指针时，编译器只会匹配基类的析构函数；而派生类中新增的成员（如堆内存、文件句柄等）的清理逻辑都在派生类析构函数中，这部分逻辑未执行就会造成资源残留。

需要注意的是：虚函数的传递性是自上而下的 —— 只有当基类的函数被声明为 `virtual`，派生类的同名函数才会自动成为虚函数；反之，仅派生类声明 `virtual` 无法向上传递虚属性。也就是说，释放指针内存时，该指针对应的基类析构函数必须得声明为 `virtual`。
```cpp
class Base {
public:
    ~Base() { // 编译器确定地址
        cout << "~Base() is called." << endl;
    } // 非虚析构
};

class Derived : public Base {
public:
    ~Derived() { // 编译器确定地址
        cout << "~Derived() is called." << endl;
    } // 清理派生类资源
};

// 调用场景
Base* ptr = new Derived();
delete ptr; // 仅调用Base::~Base()
```
### 最佳实践
将基类的析构函数声明为虚函数，触发动态绑定，`delete`基指针时会从派生类析构函数开始执行，再逐层调用基类析构函数，确保所有资源被释放。缺点就是虚函数的调用需要通过 `vptr` 查找 `vtable`，比普通函数调用多一层间接寻址，有微小但可累积的性能开销，因此只有**作为基类且可能被用来多态删除对象的类**，才需要将析构函数声明为虚函数。

```cpp
class Base {
public:
    virtual ~Base() { // 虚析构函数
        cout << "~Base() is called." << endl;
    }
};
```